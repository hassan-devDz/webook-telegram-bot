const axios = require("axios");
const { PrismaClient } = require("@prisma/client");
const config = require("../config");
const notificationService = require("./notificationService");

const prisma = new PrismaClient();
// ÿ•ÿ∂ÿßŸÅÿ© logger ÿ®ÿ≥Ÿäÿ∑
const logger = {
  info: (message) =>
    console.log(`[INFO] ${new Date().toISOString()} - ${message}`),
  error: (message, error) =>
    console.error(`[ERROR] ${new Date().toISOString()} - ${message}`, error),
  debug: (message) =>
    console.log(`[DEBUG] ${new Date().toISOString()} - ${message}`),
};
class EventService {
  constructor() {
    this.apiClient = axios.create({
      baseURL: config.weebook.apiUrl,
      timeout: config.weebook.timeout,
      headers: config.weebook.headers,
    });
    this.isFirstRun = true;
  }

  async initialize() {
    try {
      // ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ÿ¨ŸÑÿ® ÿßŸÑŸÅÿπÿßŸÑŸäÿßÿ™
      await this.startFetchingEvents();
    } catch (error) {
      console.error("Error initializing EventService:", error);
    }
  }

  startFetchingEvents() {
    // ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ŸÅŸàÿ±Ÿä ÿπŸÜÿØ ÿßŸÑÿ®ÿØÿßŸäÿ©
    this.fetchAndProcessEvents();

    // ÿ®ÿØÿ° ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ÿßŸÑÿØŸàÿ±Ÿä ŸÉŸÑ ÿØŸÇŸäŸÇÿ©
    setInterval(() => {
      this.fetchAndProcessEvents();
    }, 60000); // 60 seconds
  }

  async fetchAndProcessEvents() {
    try {
      const { data } = await this.apiClient.post("", {
        query: `
                    query getEventListing($lang: String, $limit: Int, $skip: Int, $where: EventFilter, $order: [EventOrder]) {
                        eventCollection(locale: $lang, limit: $limit, skip: $skip, where: $where, order: $order) {
                            total
                            items {
      __typename
      sys {
        id
      }
      id
      title
      subtitle
      slug
      ticketingUrlSlug
      image11 {
        sys {
          id
          publishedAt
        }
        title
        url
        width
        height
        contentType
      }
      startingPrice
      currencyCode
      eventType
      schedule {
        openDateTime
        closeDateTime
      }
      zone {
        title
      }
      location {
        title
        city
      }
      category {
        id
        title
        slug
      }
    }
  }
}`,
        variables: {
          order: "sys_publishedAt_DESC",
          lang: "ar-SA",
          limit: this.isFirstRun ? 30 : 10, // 10 ŸÅŸä ÿ£ŸàŸÑ ŸÖÿ±ÿ©ÿå 1 ŸÅŸä ÿßŸÑŸÖÿ±ÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ©
          where: {
            AND: [
              {
                OR: [{ location: {} }],
              },
            ],
            OR: [
              { schedule: { closeDateTime_exists: false } },
              {
                schedule: {
                  closeDateTime_gte: new Date().toISOString(),
                },
              },
            ],
            visibility_not: "private",
          },
        },
      });

      const events = data.data.eventCollection.items;

      if (events.length === 0) {
        console.log("No new events found");
        return;
      }
      // ŸÜÿπŸÉÿ≥ ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÖÿµŸÅŸàŸÅÿ© ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÅÿπÿßŸÑŸäÿßÿ™ ÿßŸÑÿ£ŸÇÿØŸÖ ÿ£ŸàŸÑÿßŸã
      const reversedEvents = [...events].reverse();

      for (const event of reversedEvents) {
        const existingEvent = await prisma.event.findFirst({
          where: {
            AND: [
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑŸÅÿ±ŸäÿØ ŸÖŸÜ ÿßŸÑŸÜÿ∏ÿßŸÖ
              {
                metadata: {
                  path: "$.sysId",
                  equals: event.sys?.id,
                },
              },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÅÿπÿßŸÑŸäÿ©
              {
                metadata: {
                  path: "$.id",
                  equals: event.id,
                },
              },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿßŸÑÿπŸÜŸàÿßŸÜ
              { name: event.title },
              { publishedAt: new Date(event.image11?.sys?.publishedAt) },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ®ÿØÿßŸäÿ©
              { startDate: new Date(event.schedule.openDateTime) },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿßŸÑÿ≥ÿπÿ±
              {
                price: event.startingPrice
                  ? parseFloat(event.startingPrice)
                  : 0,
              },
             
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿßŸÑÿ±ÿßÿ®ÿ∑ (slug)
              {
                metadata: {
                  path: "$.slug",
                  equals: event.slug,
                },
              },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ©
              {
                metadata: {
                  path: "$.currencyCode",
                  equals: event.currencyCode,
                },
              },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖŸàŸÇÿπ
              {
                metadata: {
                  path: "$.locationTitle",
                  equals: event.location?.title,
                },
              },
              {
                metadata: {
                  path: "$.imageSysId",
                  equals: event.image11?.sys?.id,
                },
              },
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ŸÜŸàÿπ ÿßŸÑÿ≠ÿØÿ´ (ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ)
              ...(event.eventType
                ? [
                    {
                      metadata: {
                        path: "$.eventType",
                        equals: event.eventType,
                      },
                    },
                  ]
                : []),

              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿπŸÜŸàÿßŸÜ ÿßŸÑÿµŸàÿ±ÿ© (ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ)
              ...(event.image11?.title
                ? [
                    {
                      metadata: {
                        path: "$.imageTitle",
                        equals: event.image11.title,
                      },
                    },
                  ]
                : []),
              // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ∑ÿßÿ®ŸÇ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿµŸàÿ±ÿ© (ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ)
              ...(event.image11?.url
                ? [
                    {
                      metadata: {
                        path: "$.imageUrl",
                        equals: event.image11.url,
                      },
                    },
                  ]
                : []),
              // ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ≠ŸÇŸàŸÑ ŸáŸÜÿß ÿ•ÿ∞ÿß ŸÉŸÜÿ™Ÿê ÿ™ÿ±ŸäÿØŸäŸÜ ÿ™ÿ∂ŸÖŸäŸÜŸáÿß
              // ŸÖÿ´ŸÑ slug ÿ£Ÿà currencyCode ÿ£Ÿà ÿ∫Ÿäÿ±Ÿáÿß
            ],
          },
        });

        if (!existingEvent) {
          await this.processEvent(event);
          console.log(`Processed new event: ${event.title}`);
        } else {
          console.log(`Event already exists: ${event.title}`);
        }
      }

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿ£ŸàŸÑ ÿ™ÿ¥ÿ∫ŸäŸÑ
      if (this.isFirstRun) {
        this.isFirstRun = false;
        console.log("First run completed, switching to regular polling");
      }
    } catch (error) {
      console.error("Error fetching events:", error);
    }
  }

  async processEvent(eventData) {
    try {
          const city = eventData.location?.city || "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ";
          const locationTitle = eventData.location?.title || "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ";
      const eventToCreate = {
        name: eventData.title,
        description: eventData.subtitle || "",
        bookingLink: `https://webook.com/event/${eventData.ticketingUrlSlug}`,
        price: eventData.startingPrice
          ? parseFloat(eventData.startingPrice)
          : 0,
        availableTickets: 0,
        categoryId: await this.getOrCreateCategory(eventData.category),
        areaId: await this.getOrCreateArea(city),
        classificationId: await this.getOrCreateClassification(
          eventData.zone?.title
        ),
        startDate: new Date(eventData.schedule.openDateTime),
        endDate: new Date(eventData.schedule.closeDateTime),
        isPublished: true,
        publishedAt:new Date(eventData.image11?.sys?.publishedAt),
        metadata: {
          id: eventData.id,

          // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑÿ¨ÿØŸäÿØÿ©
          sysId: eventData.sys?.id,
          eventType: eventData.eventType,

          // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿµŸàÿ±ÿ©
          imageUrl: eventData.image11?.url,
          imageTitle: eventData.image11?.title,
          imageSysId: eventData.image11?.sys?.id,

          currencyCode: eventData.currencyCode,
          slug: eventData.slug,
          locationTitle: locationTitle,
        },
      };

      const newEvent = await prisma.event.create({
        data: eventToCreate,
      });

      logger.info(`‚ú® New event created: ${newEvent.name}`);

      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖŸáÿ™ŸÖŸäŸÜ
      const interestedUsers = await this.findInterestedUsers(newEvent);
      if (interestedUsers.length > 0) {
        await notificationService.notifyUsersAboutEvent(
          newEvent,
          interestedUsers
        );
        logger.info(
          `üîî Notified ${interestedUsers.length} users about event: ${newEvent.name}`
        );
      } else {
        logger.info(`‚ÑπÔ∏è No interested users found for event: ${newEvent.name}`);
      }
    } catch (error) {
      logger.error(`‚ùå Error processing event: ${eventData.title}`, error);
    }
  }

  async findInterestedUsers(event) {
    try {
      return await prisma.user.findMany({
        where: {
          AND: [{ isSubscribed: true }, { isBlocked: false }],
        },
        include: {
          preferences: {
            include: {
              categories: {
                where: {
                  categoryId: event.categoryId,
                },
              },
              areas: {
                where: {
                  areaId: event.areaId,
                },
              },
            },
          },
        },
      });
    } catch (error) {
      logger.error("Error finding interested users:", error);
      return [];
    }
  }

  async getOrCreateCategory(categoryData) {
    const category = await prisma.category.upsert({
      where: { name: categoryData.title },
      update: {},
      create: { name: categoryData.title },
    });
    return category.id;
  }

  async getOrCreateArea(cityName) {
    const area = await prisma.area.upsert({
      where: { name: cityName },
      update: {},
      create: { name: cityName },
    });
    return area.id;
  }

  async getOrCreateClassification(zoneName = "Default") {
    const classification = await prisma.classification.upsert({
      where: { name: zoneName },
      update: {},
      create: { name: zoneName },
    });
    return classification.id;
  }
}

// ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© Ÿàÿßÿ≠ÿØÿ© ŸÖŸÜ ÿßŸÑÿÆÿØŸÖÿ©
const eventService = new EventService();

// ÿ™ÿµÿØŸäÿ± ÿßŸÑÿÆÿØŸÖÿ©
module.exports = eventService;
